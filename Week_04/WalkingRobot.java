class Solution {
    public int robotSim(int[] commands, int[][] obstacles) {
    // 总体思想：模拟机器人行走过程，计算每一步坐标点到原点的欧式距离的平方
    // 与保存的最大值比较，实时更新最大值

    // 1.分解机器人行走
    // 走k步，就是朝着一个方向走k个1步
    // 怎么朝着某个方向走出一步

    // 方向向北，机器人坐标点向上走一步
    // 方向向东，机器人坐标点向右走一步
    // 方向向南，机器人坐标点向下走一步
    // 方向向西，机器人坐标点向上左一步

    // int direx[] = {0,1,0,-1};
    // int direy[] = {1,0,-1,0};
    // direx[],direy[] 要竖着对齐看
        // - 向北，坐标轴上x不动，y+1, 即(0,1)
        // - 向东，坐标轴上x+1，y不动, 即(1,0)
        // - 向南，坐标轴上x不动，y-1, 即(0,-1)
        // - 向西，坐标轴上x-1，y不动, 即(-1,0)
    // 走( direx[i], direy[i] )，加上当前坐标后为 (curx,cury) + ( direx[i], direy[i] )

    // 2.机器人如何调整方向
    // direx[]direy[] 的下标 i 代表了当前机器人的方向
        // i=0,向北
        // i=1,向东
        // i=2,向南
        // i=3,向西
    // 当读取到调整方向的指令时，如
        // "-1"：“向右转90度”，只要当前方向curdire + 1就可以得到右转方向
        // "-2"：“向左转90度”，只要当前方向curdire + 3 就可以得到左转方向 (curdire + 3) % 4，
        // 因为不管curdire当前是哪个方向，左转都在其左边，在direx数组的定义中顺势针数3个就是其左边，所以就是加3

    //3.怎么判断是否遇到了障碍物
        // 障碍物有多个，所以需要有一个障碍物坐标点集合
        // 机器人每试图走一个位置，就用此位置与障碍物集合列表里的坐标进行比较，看是否刚好是障碍物坐标点

        // 不是，则“真正走到这个点”，更新机器人坐标点(curx,cury)
        // 是障碍物，那么不走下一步，停留在当前，执行下一条命令

        Set<String> s = new HashSet<>();
        for (int[] o : obstacles)
            s.add(o[0] + "," + o[1]);
        int max = 0, x = 0, y = 0, dir = 0, dirs[][] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        for (int c : commands)
            if (c == -2)
                dir = (dir + 3) % 4;
            else if (c == -1)
                dir = (dir + 1) % 4;
            else {
                int[] xy = dirs[dir];
                while (c-- > 0 && !s.contains((x + xy[0]) + "," + (y + xy[1]))) {
                    x += xy[0]; y += xy[1];
                }
                max = Math.max(max, x * x + y * y);
            }
        return max;
    }
}